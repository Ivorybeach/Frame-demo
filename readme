-----------------------传递json和表单序列化未实现，等待jqury-----------------------------------

ContextLoaderListener
	可以初始化SpringIoC容器(WebApplicationContext)，容器的init和destory调用ContextLoader中的方法，方法的具体实现在ContextLoader
	中完成。
	WebApplicationContext接口继承ApplicationContext,本身代表一个SpringIoC容器。
	如果取消使用web.xml，需要手动继承WebApplicationInitializer，前提是需要servlet 3.0+环境。
	
DispatcherServlet
	Springmvc核心组件，可以拦截HTTP请求；本质上仍是一个servlet;
	DispatcherServlet在实例化的时候需要传入webApplicationContext
	
数据模型
	Model、ModelAndView、ModelMap
	ModelAndView中有一个属性是ModelMap，ModelMap继承LinkedHashMap；
	Model接口，实现类ExtendedModelMap，extend ModelMap，implement Model
	模型的addAttribute()、addObject()方法，本质上都是调用hashMap.put(key,value)方法
	之所以总结这个，是在excel视图demo中，传入Map(String,Object)参数就可以获得保存在模型中的("roleList",roleList)，然后将list数据
	放入excel视图中

SpringMVC初始化流程：
	SpringIoC容器(webApplicationContext)首先进行初始化，过程中调用onRefresh()方法，将SpringMVC各个组件初始化；
	SpringIoC创建完成后，DispatcherServlet实例化时需要用到webApplicationContext

SpringMVC流程：
	HandlerMapping是URI与Handler之间的对应关系，给Handler加入拦截器使之可以在拦截器前后加入代码，得到HandlerExecutionChain；
	当DispatcherServlet拦截到请求，根据HandlerMapping找到对应的Handler，通过HandlerAdapter执行HandlerExecutionChain，
	Handler返回相应的数据模型和视图返回给DispatcherServlet，DispatcherServlet将视图发送给ViewResolver，如果是逻辑视图，
	ViewResolver解析视图并将模型渲染到视图中，如果是非逻辑视图...

handler包括controller和其他组件，比如HttpMessageConvert，用于进行简单的消息转换，将原始HTTP参数转换为java类型，或者将controller
结果转换为特定形式(如ResponseBody将结果转换为json)，根据请求头或响应头的'Accept'属性来匹配相应的HttpMessageConvert实现类，如
MappingJackson2HttpMessageConvert，用于json格式的转换；在spring初始化的时候，会自动初始化HttpMessageConvert实现类
HttpMessageConvert只能进行简单类型的转换，转换为pojo，要用到convert，转换为集合用GenericConvert

转换器Converter
	Converter接口用于简单类型转换，只有一个convert方法；
	ConditionGenericConverter接口用于转换为集合；
	Spring自动提供了基于Converter和ConditionGenericConverter接口的转换类，用于不同数据类型的转换，能够满足大多要求，一般而言，不需
	要自己进行转换；日期类型转换器也只是实现string和Date对应的一种方式而已。	
	
日期类型转换
	1.在pojo中的Date属性中加入@DateTimeFormat(pattern="yyyy-MM-dd")注解，这样只要前台的输入日期为yyyy-MM-dd类型就能够顺利转换
	为java的Date类型
	2.加入日期类型转换器，
		（1）实现Converter接口转换，定义好com.test.util.StringToDateConverter之后，在xml中注册之；
		（2）使用@InitBinder操作HTTP参数，@ControllerAdvice使全局配置生效
			值得注意的是spring3和spring3之后@InitBinder实现的方式有所不同，原因是<mvc:annotation-driven>的request
		Method和request Mapping的默认实现类发生改变，由DefaultAnnotationHandlerMapping变为RequestMappingHandlerMapping、
		AnnotationMethodHandlerAdapter --> 	RequestMappingHandlerAdapter；
		这里是spring3之后的方法，直接@InitBinder修改参数，@ControllerAdvice应用到全局controller，不需要在xml中定义bean；
	
全局异常处理器：
	1.@ControllerAdvice+@ExceptionHandler
		@ExceptionHandler只负责跳转异常页面，@ControllerAdvice用于应用全局controller
		这里是将错误信息保存在数据模型中，然后在前台用${}取出，更成熟的方法是返回给前台一致的json数据，等待在知通demo中实现
		注意：必须是controller抛出的异常才可以捕获
	2.实现HandlerExceptionResolver接口	

国际化：
	1.localeResolver：SessionLocaleResolver、CookieLocaleResolver，seesion默认30分钟失效，cookie可能会被禁用；这里是
	SessionLocaleResolver，如果有custom setting的话，会读取session中的locale attribute，否则的话使用defaultLocale；
	2.LocaleChangeInterceptor，拦截器接口，继承HandlerInterceptorAdapter，复写preHandler()方法，用于拦截locale参数
	(自定义为language)判断locale；doc:allows for changing the current locale on every request；
	3.messageSource：用于加载国际化文件*.properties，ReloadableResourceBundleMessageSource支持热加载，设置60分扫描一次
	
URI：Uniform Resource Identifier，统一资源标识符，identifier就表明是用来唯一标识资源的，相当于资源的唯一的、不会重复的名字
URL：Uniform Resource Locator，统一资源定位符，locator表明是用来定位资源的，通过URL就可以找到这个资源，URL可以看作是URI的一个子集

Media Type：媒体类型，也叫MIME类型，即HTTP协议中的Content-type，包括application/json,image/jpeg,multipart/form-datag等

UTF-8（8-bit Unicode Transformation Format）,万国码，可在在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）

两种验证方式：
	JSR 303注解，验证注解提供的简单逻辑如@NotNull,@Pattern
	Validator，验证较复杂的逻辑，@InitBinder绑定验证器
	二者不能同时使用，在@InitBinder注解下，Validator会覆盖掉JSR

excel视图的使用
	WorkBook类可用于创建excel，实现类HSSFWorkBook创建、管理*.xls(2003以前)，XSSFWorkBook创建、管理*.xlsx(2003以后)
	创建sheet之后创建row，在用row创建单元格createCell(index),setCellValue("value"),index从0开始
	workbook本意即是工作簿，用于创建、获取excel
	注意：如果不借助springmvc的AbstractExcelView视图来导出excel，可自行创建HSSFWorkBook，用文件流output/input
	复习流之后，尝试；
	可查看书签中的网页实例--------------------------------------------------------------------------------------------
	
-------------------------------------------lambda表达式学习--------------------------------------------------------------

文件上传：
	两种MultipartResolver，tandardServletMultipartResolver，依赖servlet v3.0以；ommonsMultipartResolver依赖第三方包

注解：
@RequestMapping，将URI与方法名关联
@RequestParam，从HTTP请求中获取参数，默认参数不能为空，底层实现为：
	String idStr = request.getParameter("id");
	Long id = Long.parseLong(idStr);
不提倡加入session,reqest,response对象传递参数，降低对servlet容器的依赖， 推荐使用springMVC提供的注解@RequestAttribute：
	@SessionAttribute，从session域中获取属性，@RequestAttribute在reqeust域中获取属性；
	@RequestParam和@RequestAttribute：
		request域中有prameter和attribute，parameter是客户(端)决定的，attribute是通过request.setAttribute设置的；
		故此，parameter只能request.getParam()，且得到的结果是string，而非对象，不能set；attribute可get、set，可为任意object对象；
	@CookieValue、@RequestHeader
@PathVarible，在URL中传递参数
@EnableWebMvc，一个超级复杂、重要的注解，用于初始化springmvc各种组件的实现类
@ControllerAdvice,控制器增强，doc中的内容：
	1.具有@Controller注解的作用
	2.一种特殊的@Component注解，通常与@ExceptionHandler,@ModelAttribute,@InitBinder注解联合使用，经验之谈：与@ExceptionHandler
	最常用，用于建立全局处理器
	3.basePackages="";指定拦截的controller所在包，@ControllerAdvice正如其字面意思，能够在全局意义上管理controller，所以是一种控
	制器增强
@ModelAttribute，被@ModelAttribute注释的方法会在此controller每个方法执行前被执行
	@ModelAttribute注解的方法有返回值，返回值会被保存在数据模型中；
	可以通过mv.getModelMap().get(key)或model.asMap().get(key)获取value
	可以用来保存所有controller公用的数据，或者提前需要预加载的数据
@ExceptionHandler
	如果注解中没有指定异常，以参数中的异常为拦截异常
@ResponseStatus:code,定义HTTP错误码，reason自定义原因
@WebFilter 声明一个过滤器，可以配置value和urlPattern(拦截的URL)

-----------------------------------java web基础，HTTP协议，浏览器cookie相关------------------------------------------
	
重定向和转发：
	重定向至少两次请求、两次响应，这意味着，重定向前后是两个不同的request、response，过程是浏览器向服务端发送request1，服务器接收后得到
	response1发送回浏览器，浏览器通过response1知道再向新的URL地址发送request2，得到响应response2；故重定向是客户端操作
	转发只有一次请求，一次响应，转发前后是同一个request,response，转发的过程是，浏览器发送request，服务器端接收后，通过内部转发给其他方
	法处理此reuqest，然后将响应结果response返回浏览器；故转发是服务器端操作
	重定向后url地址会发生改变，重定向适用于跨域操作，可以重定向到其他web容器的资源，转发只能在本web容器中进行转发；
	重定向两次请求，效率低于转发
	
Tomcat:
	修改tomcat配置文件server.xml，其中
	<Host>用于配置虚拟主机
	<Context>用于配置虚拟主机下的虚拟目录


	




