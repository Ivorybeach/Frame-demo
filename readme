事务管理器
	底层接口PlatformTransactionManager，定义创建/获取事务、提交、回滚事务的方法，事务管理器使用其实现类DataSourceTransactionManager
	在java config中，spring默认的事务管理器bean_name为transactionManager;

配置事务的方法
	1.xml
	2.@Transactional，注解在方法上；注解类，对类中所有方法生效

声名式事务
	@Transactional，用于定义事务
	在使用@Transactional注解之前配置注解驱动，xml:<tx:annotation-driven transaction-manager="transactionManager"/>
	java config:@EnableTransactionMangement
	
TransactionDefination
	接口，定义propagation,isolation常量，获取事务名称、propagatin、isolation、readOnly等的内容，其实现类可以用来保存事务信息

Spring事务管理流程：
	SpringIoC容器初始化时，扫描@Transactional注解内容，将对事务的定义保存在TransactionDefination的实现类中，容器运行时，利用AOP拦截
	@Transactional标注的类或方法，并将定义在TransactionDefination中的内容设置到相应的方法上

spring对数据库事务的约定：
	数据库连接与关闭、事务的回滚与提交，都通过AOP，交给Spring容器完成，开发者只需要关注业务本身

数据库事务ACID：
	1.原子性：Atomicity，事务中的所有操作，要么同时完成，要么同时不完成，事务中一旦出现错误，事务中的所有内容都会回滚到执行前的状态；
	2.一致性：Consistency，针对多个事务并发的情况，保证系统始终处于一致的状态，比如多个事务操纵同一份数据，数据总量500，不论每个事务如何操
	作此数据，其总量500保持一致；
	3.隔离性：Isolation，两个事务之间的隔离程度，用于描述两个事务之间的关系，比如事务A能否在B提交前读取B事务的内容；
	4.持久性：Durability，事务一旦执行完毕，其对数据的改变会永久保存在数据库中；
	
隔离级别：Isolation
	由SQL的标准规范定义，java|spring引用继承此规范
	在TransactionDefination中定义ISOLATION_DEFAULT，默认隔离级别沿用所使用的数据默认隔离级别，mysql支持四种隔离级别，默认为可重复读，
ocacle只支持读/写提交和序列化两种，默认读/写提交；经常使用的隔离级别：读/写提交
	1.脏读：dirty read，事务A能够读取事务B未提交的事务，这样的场景称为脏读；
	2.读/写提交：read commit，事务A只能读取事务B已经提交的数据，会产生不可重复读问题(unrepeatable read)；
		不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，导致结果不一致，
		针对update/delete操作，解决可以用锁锁住目标行，锁住之后，不可以update|delete，insert又不造成不可重复读问题，所以解决；
	3.可重复读：repeatable read，注意是针对数据库的同一条记录，可重复读使同一条数据的读写操作按照序列化进行，解决不可重复读，导致幻读；
		幻读：phantom read，A在T1时刻查询到10条记录，在T4时刻打印10条，B在T2,T3时刻增加一条，最后A打印的结果为11条，多出的一条如同幻觉，
		称为幻读，幻读针对insert操作，解决用锁锁住表；
	4.序列化：Seralizable，注意是针对多条数据库记录，将多条数据库记录按照同一个序列化进行，解决幻读；
以上四种级别，性能依次降低，在高并发事务中，如果选择Serlazibale隔离级别会严重影响性能，因此在并发量不大的情况下，为保证数据的安全性，可以考
虑Serlizable，但是在互联网高并发系统中，通常采用读/写提交；

传播行为：Propagation
	常使用的传播行为：REQUIRED
	REQUIRED:当前方法不存在事务，创建新的事务，如果已经存在事务，沿用当前事务；
	REQUIRES_NEW:无论当前是否存在事务，都创建新的事务执行方法；
	NESTED:嵌套事务，如果调用方法抛出异常之回滚方法内部执行的SQL，主方法的SQL不会回滚，也就是当前方法事务与主方法事务是两个不同事务，与
	REQUIRES_NEW相似，差别在于，NESTED支持savepoint保存点，如果数据库本身支持savepoint，事务可以回滚到savepoint;
	
@Transactional自调用失效：
	@Transactional与SpringAOP配合进行事务管理，如果SpringAOP底层实现是JDK动态代理，这意味着对于static和非public方法，AOP不能拦截，
	因此事务管理失效；此外，如果当前类中的方法调用当前类中的方法，即自调用，AOP同样不能拦截，事务管理也会失效；
	
过长时间占用事务：
	注意事务的处理应该在service层，此外，service层不应该有占用时间长的其他操作，如果有，在执行长时间操作时，会导致@Transactional注解的方
	法长时间不能释放事务，这对数据库资源是严重浪费。
	
错误使用service:
	注意：@Transactional标注的方法，执行时会开启一个事务，事务执行完毕，关闭事务；
	错误实例：com.test.controller.RoleController

错误捕捉异常：
	在Spring事务管理的约定中：@Transactional标注的方法抛出RuntimeException及其子类异常，则回滚事务；
	如果使用try..catch语句捕获异常，但在catch{}中并未throw异常，则Spring将不能拦截到异常，也就无法回滚事务；
	
遗漏点：如何用java配置、xml的方式更改@Transaction默认拦截的异常
	
	



	
	
	